const Scope = require('../src/scope').default;
const _ = require('taujs');
let scope = null;
beforeEach(() => {
    scope = new Scope();
});

it('创建Scope实例并使用', () => {
    scope.aProperty = 1;
    expect(scope.aProperty).toBe(1);
});



it('第一次digest时监听函数应该被调用', () => {
    const watchFn = function() {
        return 'wat';
    };
    const listenerFn = jest.fn();
    scope.watch(watchFn, listenerFn);
    scope.digest();
    expect(listenerFn).toHaveBeenCalled();
});

it('watch方法以当前scope实例为参数被调用', () => {
    const watchFn = jest.fn();
    const listenerFn = () => {};
    scope.watch(watchFn, listenerFn);
    scope.digest();
    expect(watchFn).toHaveBeenCalledWith(scope);
});

it('当监听的值发生变化时Listener方法被调用', () => {
    scope.someValue = 'someValue';
    scope.counter = 0;
    scope.watch(
        (scope) => scope.someValue,
        (newValue, oldValue, scope) => {
            scope.counter++;
        }
    );

    expect(scope.counter).toBe(0);
    scope.digest();
    expect(scope.counter).toBe(1);
    scope.digest();
    expect(scope.counter).toBe(1);

    scope.someValue = 'value has been changed';
    expect(scope.counter).toBe(1);

    scope.digest();
    expect(scope.counter).toBe(2);
});

it('当监听的值为undefined时调用Listener方法', () => {
    scope.counter = 0;
    scope.watch(
        (scope) => scope.someValue,
        (newValue, oldValue, scope) => {
            scope.counter++;
        }
    );
    scope.digest();
    expect(scope.counter).toBe(1);
})

it('第一次digest时调用Listener方法,oldValue与newValue相同', () => {
    scope.someValue = 123;
    let oldValueGiven = null;
    scope.watch(
        (scope) => scope.someValue,
        (newValue, oldValue, scope) => {
            oldValueGiven = oldValue;
        }
    )
    scope.digest();
    expect(oldValueGiven).toBe(123);
});

it('省略Listener方法', () => {
    const watchFn = jest.fn();
    scope.watch(watchFn);
    scope.digest();
    expect(watchFn).toHaveBeenCalled();
});

it('同一次digest时触发watcher的链式反应', () => {
    scope.name = 'tau';
    scope.watch(
        (scope) => scope.nameUpper,
        (newValue, oldValue, scope) => {
            if (newValue) {
                scope.initial = newValue.substring(0, 1) + '.';
            }
        }
    );
    scope.watch(
        (scope) => scope.name,
        (newValue, oldValue, scope) => {
            if (newValue) {
                scope.nameUpper = newValue.toUpperCase();
            }
        }
    );
    scope.digest();
    expect(scope.initial).toBe('T.');

    scope.name = 'yuan';
    scope.digest();
    expect(scope.initial).toBe('Y.');
});

it('10次迭代之后放弃watch', () => {
    scope.counterA = 0;
    scope.counterB = 0;
    scope.watch(
        (scope) => scope.counterA,
        (newValue, oldValue, scope) => scope.counterB++
    );
    scope.watch(
        (scope) => scope.counterB,
        (newValue, oldValue, scope) => scope.counterA++
    );
    expect(() => scope.digest()).toThrow();
});

it("ends the digest when the last watch is clean", () => {
    let spy = jest.fn();
    scope.array = _.range(100);

    _.times(100, (i) => {
        scope.watch(
            (scope) => {
                spy();
                return scope.array[i];
            },
            (newValue, oldValue, scope) => {}
        )
    });

    scope.digest();
    expect(spy.mock.calls.length).toBe(200);

    scope.array[0] = 420;
    scope.array[1] = 421;
    scope.digest();
    expect(spy.mock.calls.length).toBe(302);
});